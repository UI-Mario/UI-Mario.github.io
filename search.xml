<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql个人笔记</title>
      <link href="/2020/03/20/mysql_001/"/>
      <url>/2020/03/20/mysql_001/</url>
      
        <content type="html"><![CDATA[<p>进入mysql：<code>mysql -u root -p</code></p><p>显示数据库：<code>show databases;</code></p><p>进入数据库：<code>use &lt;数据库名&gt;;</code></p><p>显示表：<code>show tables;</code></p><p>创建表：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table final_stu(</span><br><span class="line">    -&gt; id varchar(10) primary key not null,</span><br><span class="line">    -&gt; name varchar(20),</span><br><span class="line">    -&gt; sex enum(&apos;男&apos;,&apos;女&apos;,&apos;保密&apos;) default &apos;保密&apos;,</span><br><span class="line">    -&gt; enrollment year,</span><br><span class="line">    -&gt; birthday date,</span><br><span class="line">    -&gt; class varchar(20)</span><br><span class="line">    -&gt; )engine=myisam charset=utf8;</span><br></pre></td></tr></table></figure><p>增：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> final_stu <span class="keyword">values</span></span><br><span class="line">    -&gt; (<span class="string">'002'</span>,<span class="string">'李四'</span>,<span class="string">'男'</span>,<span class="number">2020</span>,<span class="string">'1994-05-25'</span>,<span class="string">'1-1'</span>),</span><br><span class="line">    -&gt; (<span class="string">'003'</span>,<span class="string">'王五'</span>,<span class="string">'男'</span>,<span class="number">2019</span>,<span class="string">'1995-04-02'</span>,<span class="string">'2-10'</span>),</span><br><span class="line">    -&gt; (<span class="string">'004'</span>,<span class="string">'周梅'</span>,<span class="string">'女'</span>,<span class="number">2020</span>,<span class="string">'1993-06-16'</span>,<span class="string">'1-1'</span>);</span><br></pre></td></tr></table></figure><p>删：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table final_stu drop id;</span><br></pre></td></tr></table></figure><p>改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update set name=&apos;小花&apos; sex=&apos;女&apos; where id=1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table final_stu add address varchar(20) not null default &apos;&apos; comment &apos;户籍地址&apos;;</span><br></pre></td></tr></table></figure><p>查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,id from final_stu where name like &apos;王%&apos; and id&lt;007 order by id desc limit 3;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/08/hello-world/"/>
      <url>/2020/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 学习之路</title>
      <link href="/2020/02/20/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/02/20/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h1><ul><li>位（bit），表示二进制位（0 或 1）</li><li>字节（byte），它由 8 个二进制位组成，即<code>1 byte = 8 bit</code>，是计算机内部计量的基本单位。一个英文字节占 1 个字节，一个汉字占 2 个字节。</li><li>字（word），它由若干个字节构成，是计算机内部进行数据处理和运算的基本单位。字的总的位数称为字长，不同档次的计算机字长是不一样的，比如 32 位机，它的 1 个字由 4 个字节构成，字长为 32 位，也就是说其 CPU 一次操作处理的实际位数是 32 位。同理，64 位机可以处理 64 位。由此可见，计算机的字长越大，其性能越优越。</li></ul><a id="more"></a><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>为什么要编码呢？因为计算机只能理解 0 和 1，像字母、汉字等字符需要编码成 0 和 1 才能被计算机所理解</p><p>由字符到二进制数称为编码，反过来则是解码。</p><h2 id="常见编码规则"><a href="#常见编码规则" class="headerlink" title="常见编码规则"></a>常见编码规则</h2><ul><li><p>_ASCII_，即 American Standard Code for Information Interchange（美国信息交换标准代码）。由于计算机是美国人发明的本来一个字节有 8 位，每一位有 0 和 1 两种状态，则一个字节共有 2^8=256 种状态，可以表示 256 种字符。但是美国佬觉得只要可以表示自己的字母和一些特殊字符就足够了，所以 ASCII 没有占用最高位（而是固定为 0），实际只用到了后面 7 位，它可以表示 2^7=128 种状态，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码。但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去</p></li><li><p>_Unicode_，解决了编码统一的问题。每种语言的每个字符在 Unicode 的规则下，都只有统一且唯一的对应二进制编码。 缺点在于 Unicode 一般用两个字节表示一个字符，在某些情况下会出现极大浪费。</p></li><li><p>_UTF-8_，UTF-8 是 Unicode 的一种实现方式。其他实现方式还包括 UTF-16 和 UTF-32。UTF-8 是一种变长编码，根据具体字符来变更所需的表示字节。它将基本 7 位 ASCII 字符仍用 7 位编码表示，占用一个字节（首位补 0）。而遇到与其他 Unicode 字符混合的情况，将按一定算法转换，每个字符使用 1-3 个字节编码，并利用首位为 0 或 1 进行识别。这样对以 ASCII 字符为主的英文文档就大幅节省了编码长度。</p></li></ul><h1 id="java-基础知识"><a href="#java-基础知识" class="headerlink" title="java 基础知识"></a>java 基础知识</h1><p>java 虚拟机（Java Virtual Machine），JVM</p><p>垃圾回收机制（Garbage collection），GC</p><p>Java 开发工具包（Java Development Kit），JDK（包含 JRE）</p><p>Java 运行环境（Java Runtime Environment），JRE（包含 JVM 和核心库）</p><p>java 三大体系：</p><ul><li>JavaSE（J2SE）（Java2 Platform Standard Edition，Java 平台标准版）</li><li>JavaEE（J2EE）（Java2 Platform Enterprise Edition，Java 平台企业版）</li><li>JavaME（J2ME）（Java2 Platform Micro Edition，Java 平台微型版）</li></ul><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/02/ff803b82be619d66.png" alt=""></p><p><img src="https://ftp.bmp.ovh/imgs/2020/02/63566ea364d8cfd8.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中戳中痛点的问题</title>
      <link href="/2019/12/31/vue%E4%B8%AD%E6%88%B3%E4%B8%AD%E7%97%9B%E7%82%B9%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/31/vue%E4%B8%AD%E6%88%B3%E4%B8%AD%E7%97%9B%E7%82%B9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>这个问题本来在vue-cli里是可以很优雅的解决的，但是由于本人缺乏相关经验和知识，愣是被浪费了一个下午，怒而提笔</p><p>重点提一下版本：vue-cli3.x</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先来讲讲这篇文章能帮你干什么</p><p>假如你有一个api，本文中所举栗子是<code>http://api.bilibili.cn/recommend</code>，这是一个死数据接口，但是很合适用来讲解。但是你不能直接用<code>axios</code>或者<code>fetch</code>获取api里的数据，例如</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">'`http://api.bilibili.cn/recommend`'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>会报错，所以你需要在vue-cli3.x里进行设置，步骤如下</p><p>创建一个<code>vue.config.js</code>的文件，与<code>package.json</code>位于同一目录，用来设置代理</p><p>代码如下</p><p><code>vue.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  outputDir: <span class="string">'dist'</span>, <span class="comment">//build输出目录</span></span><br><span class="line">  assetsDir: <span class="string">'assets'</span>, <span class="comment">//静态资源目录（js, css, img）</span></span><br><span class="line">  <span class="comment">// lintOnSave: false, //是否开启eslint</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'8081'</span>,</span><br><span class="line">    https: <span class="literal">false</span>, <span class="comment">//是否使用https协议</span></span><br><span class="line">    hotOnly: <span class="literal">false</span>, <span class="comment">//是否开启热更新</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/v2'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://api.bilibili.cn'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,<span class="comment">//这个参数是用来回避跨站问题的，配置完之后发请求时会自动修改http header里面的host，但是不会修改别的</span></span><br><span class="line">        <span class="comment">//ws: true,  //如果要代理 websockets，配置这个参数</span></span><br><span class="line">        <span class="comment">//secure: false,  // 如果是https接口，需要配置这个参数</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/v2'</span>: <span class="string">''</span>  <span class="comment">//替换规则，配置是正则表达式</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>某个.vue文件里的代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">...</span><br><span class="line">  created () &#123;</span><br><span class="line">    this.fetch()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetch () &#123;</span><br><span class="line">      axios</span><br><span class="line">        .get(&apos;/v2/recommend&apos;)    //调用axios</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">          console.log(res.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(() =&gt; &#123;</span><br><span class="line">          console.log(&apos;error&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>至此，跨域就成功了。当然，换一个api这个代码肯定就失败了，所以下面就对这上面的代码进行讲解。</p><p>首先讲讲<code>vue.config.js</code>，它的核心部分其实就是<code>proxy</code>那段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/v2'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://api.bilibili.cn'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,<span class="comment">//这个参数是用来回避跨站问题的，配置完之后发请求时会自动修改http header里面的host，但是不会修改别的</span></span><br><span class="line">    <span class="comment">//ws: true,  //如果要代理 websockets，配置这个参数</span></span><br><span class="line">    <span class="comment">//secure: false,  // 如果是https接口，需要配置这个参数</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/v2'</span>: <span class="string">''</span>  <span class="comment">//替换规则，配置是正则表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这段代码干了什么呢，首先看<code>/v2</code>，很明显这是一个url的一部分；它从哪来，当然是从调用<code>axios</code>时输入的url来，本文中它的来源是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.get(<span class="string">'/v2/recommend'</span>)</span><br></pre></td></tr></table></figure><p>他的意思就是找到你输入的url的某个位置，本文中是<code>v2</code>，然后通过<code>target</code>和<code>changeOrigin</code>把url变成这种形式<code>http://api.bilibili.cn/v2/recommend</code></p><p>对于部分api，这种变化呢其实就可以解决问题了，从原始的<code>https://localhost:8081/v2/recommend</code>变成了<code>http://api.bilibili.cn/v2/recommend</code>，但由于有的api就缺这么个定位的<code>v2</code>，例如本文中的api：<code>http://api.bilibili.cn/recommend</code>，所以后面就用<code>pathRewrite</code>来抹掉<code>v2</code>，把它匹配成空字符。</p><p>所以有的时候这里<code>proxy</code>的写法可能千奇百怪，但其实那个<code>v2</code>一点都不重要，就是用来定位的，重要的是你<code>target</code>和<code>axios.get()</code>里的url必须写对。</p><p><strong>附带</strong>：网上搜了很多博客，清一色的<code>proxyTable:</code>而不是<code>proxy:</code>，本文中两者间不能进行替换，大概是vue-cli2.x和vue-cli3.x的锅吧。</p><h1 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h1><p>两种方式：</p><ol><li>query（传一个对象）</li><li>params+动态路由（传变量）</li></ol><p>TODO:</p><h1 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h1><p>把组件里写了个路由嵌套，结果组件被渲染两次，查找原因中</p>]]></content>
      
      
      <categories>
          
          <category> 填坑 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 跨域 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习-缓存</title>
      <link href="/2019/12/20/web%E7%BC%93%E5%AD%98/"/>
      <url>/2019/12/20/web%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="computed属性-amp-method方法"><a href="#computed属性-amp-method方法" class="headerlink" title="computed属性&amp;method方法"></a>computed属性&amp;method方法</h1><blockquote><p>其实官网上解释得很清楚了，笔者只是进行归纳总结，<a href="[https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95](https://cn.vuejs.org/v2/guide/computed.html#计算属性缓存-vs-方法)">官方文档</a></p></blockquote><p>就像官网上的例子，我们可以通过在表达式中调用方法来达到同样的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看出两种方式的最终结果确实是完全相同的</p><p>但是总结下来两者间的最主要差别就是：</p><p><strong>computed有缓存功能，methods没有</strong></p><p>So，缓存有什么用？</p><h1 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h1><p>先简单介绍一下<em>web缓存</em></p><blockquote><p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p></blockquote><p>在Web应用领域，Web缓存大致可以分为以下几种类型：</p><h2 id="数据库数据缓存"><a href="#数据库数据缓存" class="headerlink" title="数据库数据缓存"></a>数据库数据缓存</h2><p>Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。</p><h2 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h2><h3 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h3><p>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等，这里不再详述。</p><h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。</p><h2 id="浏览器端缓存-http缓存"><a href="#浏览器端缓存-http缓存" class="headerlink" title="浏览器端缓存/http缓存"></a>浏览器端缓存/http缓存</h2><p>浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。</p><h2 id="web应用层缓存"><a href="#web应用层缓存" class="headerlink" title="web应用层缓存"></a>web应用层缓存</h2><p>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p><h1 id="浏览器端缓存浅析"><a href="#浏览器端缓存浅析" class="headerlink" title="浏览器端缓存浅析"></a>浏览器端缓存浅析</h1><p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><h2 id="浏览器端缓存机制"><a href="#浏览器端缓存机制" class="headerlink" title="浏览器端缓存机制"></a>浏览器端缓存机制</h2><p><img src="https://s2.ax1x.com/2019/12/20/QOMBes.png" alt="浏览器缓存示意图"></p><p>（图片来自<a href="https://github.com/ljianshu/Blog）" target="_blank" rel="noopener">https://github.com/ljianshu/Blog）</a></p><h3 id="按缓存位置分类：（留待更新）"><a href="#按缓存位置分类：（留待更新）" class="headerlink" title="按缓存位置分类：（留待更新）"></a>按缓存位置分类：（留待更新）</h3><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><h3 id="按失效策略分类："><a href="#按失效策略分类：" class="headerlink" title="按失效策略分类："></a>按失效策略分类：</h3><p>（先验知识：http协议、报文、缓存相关请求响应头等）</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><h2 id="浏览器端缓存的控制"><a href="#浏览器端缓存的控制" class="headerlink" title="浏览器端缓存的控制"></a>浏览器端缓存的控制</h2><p>Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 底层机制</title>
      <link href="/2019/12/12/js%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/12/js%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><p>JavaScript 脚本语言具有以下特点:</p><ul><li>脚本语言。JavaScript 是一种解释型的脚本语言，是在程序的运行过程中逐行进行解释执行，不需要预编译；而 Java、C++ 等语言需要先编译后执行；</li></ul><ul><li>动态性。JavaScript 能够动态修改对象的属性，没有办法在编译的时候知道变量的类型，只有在运行的时候才能确定；而 Java、C++ 等都是静态类型语言，他们在编译的时候就能够知道每个变量的类型；</li></ul><ul><li>跨平台性。JavaScript 脚本语言不依赖于操作系统，仅需要浏览器的支持。可以在多种平台下运行（如 Windows、Linux、Mac、Android、IOS 等）</li></ul><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/nV75KBmRGpcE7Pn5Z-HUFg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nV75KBmRGpcE7Pn5Z-HUFg</a></p><p><strong>附加</strong>：<strong>JavaScript 比 Java 慢的原因</strong><br>和大多数解释型语言一样，JavaScript 运行也比较慢，和 Java 等静态编译语言相比，究其原因大概有：</p><ul><li>JavaScript 变量无类型信息，不能做偏移信息查找，偏移信息共享等编译阶段的优化</li><li>JavaScript 将源码编译为字节码的过程要占用运行时间，而 Java 的编译则是开发阶段，不占用任何运行时间。故 Java 可以尽可能的在编译阶段做优化</li><li>附：想深入理解建议去看编译原理</li></ul><h1 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h1><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>JavaScript 中有三种执行上下文类型。</p><ul><li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</li></ul><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><blockquote><p>ES5 标准文档中规定，执行环境包括：词法环境、变量环境、this 绑定。并且解释道：其中执行环境的词法环境和变量环境组件始终为词法环境对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件永远不变，而词法环境组件有可能改变。</p></blockquote><blockquote><p>ES6 中规定，<strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p></blockquote><ol><li>this 绑定</li><li>创建词法环境（Lexical Environments）</li><li>创建变量环境</li></ol><p>想要具体了解 js 执行时发生的事请转往：<a href="https://juejin.im/post/5c855410e51d45555e2626fd" target="_blank" rel="noopener">【译】JS 的执行上下文和环境栈是什么？</a></p><h1 id="执行栈-Execution-Stack"><a href="#执行栈-Execution-Stack" class="headerlink" title="执行栈(Execution Stack)"></a>执行栈(Execution Stack)</h1><p>执行栈，就是用来存储代码执行时的所有执行上下文，是一种 LIFO（后进先出）的数据结构。</p><p>JavaScript 是一门单线程的编程语言，因此它只能一次做一件事。所以当我们运行某段代码的时候，把它的执行上下文放入栈顶，当执行完毕代码后便把相应的执行上下文从栈顶弹出。</p><h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><ol><li>所有同步任务都在主线程上执行，形成一个<a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener">执行栈</a>（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><h1 id="js-引擎"><a href="#js-引擎" class="headerlink" title="js 引擎"></a>js 引擎</h1><p>虽然浏览器非常多，但是主流的 JavaScirpt 引擎其实很少，毕竟开发一个 JavaScript 引擎是一件非常复杂的事情。比较出名的 JS 引擎有这些：</p><ul><li><a href="https://v8.dev/" target="_blank" rel="noopener">V8</a> (Google) //Chrome 与 Node.js 都使用了 V8</li><li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> (Mozilla)</li><li><a href="https://developer.apple.com/documentation/javascriptcore?language=objc" target="_blank" rel="noopener">JavaScriptCore</a> (Apple)</li><li><a href="https://github.com/microsoft/ChakraCore" target="_blank" rel="noopener">Chakra</a> (Microsoft)</li><li>IOT：<a href="https://github.com/svaarala/duktape" target="_blank" rel="noopener">duktape</a>、<a href="https://github.com/jerryscript-project/jerryscript" target="_blank" rel="noopener">JerryScript</a></li></ul><p>还有，最近发布<a href="https://bellard.org/quickjs/" target="_blank" rel="noopener">QuickJS</a>与<a href="https://hermesengine.dev/" target="_blank" rel="noopener">Hermes</a>也是 JS 引擎，它们都超越了浏览器范畴，<a href="https://link.zhihu.com/?target=https%3A//bellard.org/quickjs/">QuickJS</a>是大神<a href="https://en.wikipedia.org/wiki/Fabrice_Bellard" target="_blank" rel="noopener">Fabrice Bellard</a>)发布的，可以将 JavaScript 源码转换为 C 语言代码，然后再使用系统编译器(gcc 或者 clang)生成可执行文件。Facebook 为 React Native 开发了新的 JS 引擎<a href="https://link.zhihu.com/?target=https%3A//hermesengine.dev/">Hermes</a>，用于优化安卓端的性能。它可以在构建 APP 的时候将 JavaScript 源码编译为 Bytecode，从而减少 APK 大小、减少内存使用，提高 APP 启动速度。<a href="https://blog.codinghorror.com/the-principle-of-least-power/" target="_blank" rel="noopener">Atwood’s Law</a>再次得到了证明：</p><blockquote><p>Any application that can be written in JavaScript, will eventually be written in JavaScript.</p></blockquote><p>JavaScriptCore 的大致流程：JavaScript 源代码 -&gt; 抽象语法树（AST）-&gt; 字节码-&gt; 本地代码</p><p>V8 的大致流程：JavaScript 源代码 -&gt; 抽象语法树（AST）-&gt; 本地代码 （2017 年 4 月发布 5.9 版本后新增了 Ignition 字节码解释器，与 JScore 流程大致相同）</p><p>这是因为编程语言有两个类别：<strong>静态类型和动态类型</strong>。静态类型的语言，比如 C++、Go 等，都需要提前编译 <strong>（AOT）</strong> 成机器码然后执行，这个过程主要使用编译器来完成；而动态语言，比如 JavaScript、Python 等，只在运行时进行编译执行 <strong>（JIT）</strong> ，这个过程通过解释器完成。</p><p><strong>JIT(Just-in-Time)</strong></p><p><strong>AOT(Ahead-of-Time)</strong></p><p><strong>抽象语法树(Abstract Syntax Tree, AST)</strong></p><p><strong>编译器（Compiler）</strong> 或者<strong>解释器（Interpreter)</strong></p><h1 id="v8-的垃圾回收机制"><a href="#v8-的垃圾回收机制" class="headerlink" title="v8 的垃圾回收机制"></a>v8 的垃圾回收机制</h1><p>在 v8 里，内存对象被分成了两种，新生代对象和老生代对象，两者各放在不同的内存空间中，也就是：新生代内存空间和老生代内存空间。他们都有各自的垃圾回收算法。</p><p><img src="https://s2.ax1x.com/2019/12/12/Q6IFkn.png" alt=""></p><h2 id="新生代回收算法-scavenge"><a href="#新生代回收算法-scavenge" class="headerlink" title="新生代回收算法 scavenge"></a>新生代回收算法 scavenge</h2><p>1.把新生代内存区再均分成两块，每一块都叫做 semispace，这两个只有一个处于使用状态(称为 From 空间)，一个处于闲置状态(称为 To 空间)</p><p>2.新分配的对象放入 From 空间中。</p><p>3.开始垃圾回收时，检查 From 中所有存活的对象，把他们复制到 To 空间中，然后回收整个 From 空间。</p><p>4.From 和 To 互换角色，重复之前的过程。</p><p>5.如果一个对象经过多次复制后，仍然存活，它会被认为是生命周期较长的对象，随后会被移动到老生代中，这个过程叫做对象的晋升，晋升的条件有两个：一是对象经历过 scavenge 回收过程仍然存活，二是 To 空间内存占用比超过限制，一般是 To 空间已经使用了超过 25%时</p><h2 id="老生代回收算法-Mark-Sweep-配合-Mark-Compact"><a href="#老生代回收算法-Mark-Sweep-配合-Mark-Compact" class="headerlink" title="老生代回收算法 Mark-Sweep 配合 Mark-Compact"></a>老生代回收算法 Mark-Sweep 配合 Mark-Compact</h2><h3 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>标记阶段时遍历所有老生代中的对象，标记活着的对象，清除阶段时只清除没有被标记的。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于标记的随机性，内存出现不连续的状态，被切割成很多小块，导致没有充足的空间分配给大对象。</p><h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>为了解决 sweep 的缺点，提出了这个算法，它不同之处在于，对象被标记死亡后，整理过程中，会将活着的对象往一端移动，移动完成后，直接把另一端，边界外的对象全部清理掉。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>移动对象的过程会导致性能损耗，执行速度不会很快</p><h3 id="标记过程优化"><a href="#标记过程优化" class="headerlink" title="标记过程优化"></a>标记过程优化</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>由于垃圾回收时，应用的逻辑会被暂停，以避免发生 js 逻辑层与垃圾回收器数据不一致，因此一次垃圾回收时间过长时肯定会导致性能大幅下降。</p><h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><p>V8 在标记阶段，会将一次性标记改成增量标记，叫做 incremental marking，拆成很多小步进行步进，以避免每次回收时间过长。</p><p><strong>参考:</strong></p><p><a href="https://www.yuque.com/lvshukai/rfgt5x/kcgw1z" target="_blank" rel="noopener">v8 的垃圾回收机制-语雀</a></p><p><a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be" target="_blank" rel="noopener">聊聊 v8 的垃圾回收-掘金</a></p><p>当然强烈推荐去看编译原理，上面更多方法实现垃圾回收。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端 </tag>
            
            <tag> js 引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative填坑</title>
      <link href="/2019/12/06/RN%E5%A1%AB%E5%9D%91/"/>
      <url>/2019/12/06/RN%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Error-ENOSPC-System-limit-for-number-of-file-watchers-reached"><a href="#Error-ENOSPC-System-limit-for-number-of-file-watchers-reached" class="headerlink" title="Error: ENOSPC: System limit for number of file watchers reached"></a>Error: ENOSPC: System limit for number of file watchers reached</h1><p>在使用React Native做开发时，执行react-native start时弹出如上错误</p><p>意思是系统对文件监控的数量已经到达限制数量了。</p><a id="more"></a><p>解决方法：修改限制数量</p><p>系统：Ubuntu</p><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>会打开一个目录，这里面都是一些内核参数，添加一行在最下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.inotify.max_user_watches=524288</span><br></pre></td></tr></table></figure><p>保存退出后，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p>查看是否修改成功，若出现你写在最下面的那一行代码，则修改成功。</p><h1 id="Task-app-installDebug-FAILED-Deprecated-Gradle-features-were-used-in-this-build-making-it-incompatible-with-Gradle-6-0"><a href="#Task-app-installDebug-FAILED-Deprecated-Gradle-features-were-used-in-this-build-making-it-incompatible-with-Gradle-6-0" class="headerlink" title="Task :app:installDebug FAILED,Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0."></a>Task :app:installDebug FAILED,Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.</h1><p>一般来说，你真机没连上而已。如果后面有具体报错信息，那慢慢改吧</p><h1 id="通过react-native-splash-screen设置启动图片"><a href="#通过react-native-splash-screen设置启动图片" class="headerlink" title="通过react-native-splash-screen设置启动图片"></a>通过react-native-splash-screen设置启动图片</h1><p>跟着github上的官方指导做了半天，卡死在一个地方：</p><p><code>MainApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以前版本的reactnative</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">            <span class="keyword">new</span> MainReactPackage(),</span><br><span class="line">    <span class="keyword">new</span> SplashScreenReactPackage()  <span class="comment">//here</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的react-native --version =&gt;0.615</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"UnnecessaryLocalVariable"</span>)</span><br><span class="line">  List&lt;ReactPackage&gt; packages = <span class="keyword">new</span> PackageList(<span class="keyword">this</span>).getPackages();</span><br><span class="line">  <span class="comment">// Packages that cannot be autolinked yet can be added manually here, for example:</span></span><br><span class="line">  <span class="comment">// packages.add(new MyReactNativePackage());</span></span><br><span class="line">  <span class="keyword">return</span> packages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至今没搞懂这是啥，暂且留着，以后学得差不多了再回来看吧。</p><p>我的步骤：</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>yarn add react-native-splash-screen</code></p><p>我的会自动link，就不需要手动link了。</p><h2 id="配置Android"><a href="#配置Android" class="headerlink" title="配置Android"></a>配置Android</h2><p>修改<code>MainActivity.java</code>文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">+ <span class="keyword">import</span> android.os.Bundle;</span><br><span class="line">+ <span class="keyword">import</span> org.devio.rn.splashscreen.SplashScreen;<span class="comment">//导入相关包</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ReactActivity</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">+    <span class="meta">@Override</span></span><br><span class="line">+    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">+       SplashScreen.show(<span class="keyword">this</span>);   <span class="comment">//show(this,true)隐藏statusBar</span></span><br><span class="line">+       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">+    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>android/app/src/main/res/layout</code>文件夹下创建启动页的<code>launch_screen.xml</code>文件，如果没有layout文件夹就自己建一个。</p><p><code>launch_screen.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:background</span>=<span class="string">"@mipmap/launch_screen"</span>&gt;</span> //设置启动页图片位置</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面那一行代码的<code>@mipmap</code>指的是你放图片的文件夹的名字，这里我们是直接把RN自动生成放app图标的文件夹拿来用了，当然你也可以自己创建<code>@launch</code>之类的，不过为了适配不同显示器得创建很多文件夹，有点麻烦。</p><p>而那行<code>launch_screen</code>就是你的图片名，改完名放进文件夹。</p><p>修改<code>android/app/src/main/res/values/styles.xml</code>文件，解决启动白屏一闪而过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">+   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外，虽然我们解决了启动屏的问题，但是存在小瑕疵：</p><div style="width: 100%; display:flex; justify-content:center;">    <img src="https://s2.ax1x.com/2019/12/13/QgKBkT.jpg" style="zoom:19%;" />    <img src="https://s2.ax1x.com/2019/12/13/QgK61J.jpg" style="zoom:19%;" /></div><p>很明显我们希望隐藏掉手机屏幕上方的状态栏，让图片可以全屏显示。这里由于我不会安卓开发，也尝试过很多方法，最终用一种<strong>很蛋疼</strong>的方式实现了这个效果，即改变状态栏底色，改成白色就正好看不见，最终效果如下：</p><div style="width: 100%; display:flex; justify-content:center;">    <img src="https://s2.ax1x.com/2019/12/13/QgM658.jpg" style="zoom:19%;" />    <img src="https://s2.ax1x.com/2019/12/13/QgK61J.jpg" style="zoom:19%;" /></div><p>后面再慢慢填这个坑吧</p><h2 id="配置React-Native"><a href="#配置React-Native" class="headerlink" title="配置React-Native"></a>配置React-Native</h2><p><code>app.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> SplashScreen <span class="keyword">from</span> <span class="string">'react-native-splash-screen'</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;SplashScreen.hide()&#125;, <span class="number">3000</span>,);<span class="comment">//3秒后消失</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h1 id="react-native-swiper"><a href="#react-native-swiper" class="headerlink" title="react-native-swiper"></a>react-native-swiper</h1><p>为了使用轮播图导入了这个第三方库，但是出现一个莫名其妙的bug：</p><img src="https://ftp.bmp.ovh/imgs/2019/12/f67cb71d86405f44.jpg" style="zoom: 33%;" /><p>可我没用这个viewpageandroid啊，而且看github上两个月前还在更新，应该不存在过时的说法，也没有搜到跟我类似的问题，很郁闷。</p><p><strong><em>update</em></strong></p><p>在github的issue里找到了方法：</p><blockquote><p>I removed 1.5.14 (<code>yarn remove react-native-swiper</code>) then installed the nightly with <code>yarn add react-native-swiper@nightly</code> and it’s working on Android now.</p></blockquote><h1 id="Requiring-unknown-module-“xxx”"><a href="#Requiring-unknown-module-“xxx”" class="headerlink" title="Requiring unknown module “xxx”"></a>Requiring unknown module “xxx”</h1><p>之前去掉了一个没用的三方库</p><p><code>yarn remove teaset</code></p><p>就跳出了这个问题，解决方法也很简单</p><p><code>npm start</code></p>]]></content>
      
      
      <categories>
          
          <category> 填坑 </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怪异的javascript</title>
      <link href="/2019/12/06/%E5%A4%B4%E5%A4%A7%E7%9A%84javascript/"/>
      <url>/2019/12/06/%E5%A4%B4%E5%A4%A7%E7%9A%84javascript/</url>
      
        <content type="html"><![CDATA[<p>javascript太恐怖了，暂且先搜集点样例，后面慢慢去看吧。</p><p>几组案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较/匹配</span></span><br><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">[] == <span class="string">''</span>   <span class="comment">// -&gt; true</span></span><br><span class="line">[] == <span class="number">0</span>    <span class="comment">// -&gt; true</span></span><br><span class="line">[<span class="string">''</span>] == <span class="string">''</span> <span class="comment">// -&gt; true</span></span><br><span class="line">[<span class="number">0</span>] == <span class="number">0</span>   <span class="comment">// -&gt; true</span></span><br><span class="line">[<span class="number">0</span>] == <span class="string">''</span>  <span class="comment">// -&gt; false</span></span><br><span class="line">[<span class="string">''</span>] == <span class="number">0</span>  <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">"2"</span> == <span class="literal">true</span> <span class="comment">// flase</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> &gt; <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> &lt; <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> &gt;= <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="literal">true</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#123;&#125; + <span class="number">1</span> <span class="comment">// 1，这里的 &#123;&#125; 被当成了代码块</span></span><br><span class="line">&#123; <span class="number">1</span> + <span class="number">1</span> &#125; + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">obj + <span class="number">1</span> <span class="comment">// [object Object]1</span></span><br><span class="line">&#123;&#125; + &#123;&#125; <span class="comment">// Chrome 上显示 "[object Object][object Object]"，Firefox 显示 NaN</span></span><br><span class="line"><span class="number">1</span>+&#123;<span class="attr">a</span>:<span class="number">1</span>&#125; <span class="comment">// 1[object Object]</span></span><br><span class="line">[] + &#123;&#125; <span class="comment">// [object Object]</span></span><br><span class="line">[] + a <span class="comment">// [object Object]</span></span><br><span class="line">+ [] <span class="comment">// 等价于 + "" =&gt; 0</span></span><br><span class="line">&#123;&#125; + [] <span class="comment">// 0</span></span><br><span class="line">a + [] <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>] + [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">// '2,31,2'</span></span><br><span class="line">[<span class="number">2</span>] + <span class="number">1</span> <span class="comment">// '21'</span></span><br><span class="line">[<span class="number">2</span>] + (<span class="number">-1</span>) <span class="comment">// "2-1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//baNaNa</span></span><br><span class="line"><span class="string">'b'</span> + <span class="string">'a'</span> + + <span class="string">'a'</span> + <span class="string">'a'</span> <span class="comment">// -&gt; baNaNa</span></span><br><span class="line"><span class="string">'foo'</span> + + <span class="string">'bar'</span> <span class="comment">// -&gt; 'fooNaN'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法或其他操作，无法进行字符串连接，因此在错误的字符串格式下返回 NaN</span></span><br><span class="line">[<span class="number">2</span>] - <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>] - <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line">&#123;&#125; - <span class="number">1</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>到底是为什么呢？ 下面有一个表供快速参考：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>  + <span class="built_in">Number</span>  -&gt; addition</span><br><span class="line"><span class="built_in">Boolean</span> + <span class="built_in">Number</span>  -&gt; addition</span><br><span class="line"><span class="built_in">Boolean</span> + <span class="built_in">Boolean</span> -&gt; addition</span><br><span class="line"><span class="built_in">Number</span>  + <span class="built_in">String</span>  -&gt; concatenation</span><br><span class="line"><span class="built_in">String</span>  + <span class="built_in">Boolean</span> -&gt; concatenation</span><br><span class="line"><span class="built_in">String</span>  + <span class="built_in">String</span>  -&gt; concatenation</span><br></pre></td></tr></table></figure><p>那么其他例子呢？对于<code>[]</code>和<code>{}</code>，toPrimitive和toString方法会在加法操作前被隐式地调用。</p><ul><li><a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus" target="_blank" rel="noopener">12.8.3 The Addition Operator (+)</a></li><li><a href="[https://www.ecma-internationa...](https://www.ecma-international.org/ecma-262/#sec-toprimitive)">7.1.1 ToPrimitive(input [,PreferredType])</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-tostring" target="_blank" rel="noopener">7.1.12 ToString(argument)</a></li></ul><h1 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parsInt</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'f*ck'</span>);     <span class="comment">// -&gt; NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'f*ck'</span>, <span class="number">16</span>); <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>, <span class="number">24</span>) <span class="comment">// -&gt; 23</span></span><br></pre></td></tr></table></figure><h1 id="return"><a href="#return" class="headerlink" title="return"></a>return</h1><p>下面的函数返回的结果竟然不是对象<code>{b:10}</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#123;</span><br><span class="line">    b : <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)() <span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure><p>不过，如果稍微改写一下，就不一样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    b : <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)() <span class="comment">// -&gt; &#123; b: 10 &#125;</span></span><br></pre></td></tr></table></figure><p>这主要是因为有一个<strong>自动行尾加分号</strong>的机制在作怪，会自动在很多新行的行尾添加分号。在第一个例子中，实际上是在return后面添加了分号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#123;</span><br><span class="line">    b : <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)() <span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure><h1 id="3个number比较"><a href="#3个number比较" class="headerlink" title="3个number比较"></a>3个number比较</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span> <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure><p>我们来看看具体的执行过程就明白了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">// 1 &lt; 2 -&gt; true</span></span><br><span class="line"><span class="literal">true</span>  &lt; <span class="number">3</span> <span class="comment">// true -&gt; 1</span></span><br><span class="line"><span class="number">1</span>     &lt; <span class="number">3</span> <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span> <span class="comment">// 3 &gt; 2 -&gt; true</span></span><br><span class="line"><span class="literal">true</span>  &gt; <span class="number">1</span> <span class="comment">// true -&gt; 1</span></span><br><span class="line"><span class="number">1</span>     &gt; <span class="number">1</span> <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure><h1 id="Math-max-比Math-min-小"><a href="#Math-max-比Math-min-小" class="headerlink" title="Math.max()比Math.min()小"></a>Math.max()比Math.min()小</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>)  <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>) <span class="comment">// -&gt; 7</span></span><br><span class="line"><span class="built_in">Math</span>.min() <span class="comment">// -&gt; Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.max() <span class="comment">// -&gt; -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.min() &gt; <span class="built_in">Math</span>.max() <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>原因: <a href="https://charlieharvey.org.uk/page/why_math_max_is_less_than_math_min" target="_blank" rel="noopener">Why is Math.max() less than Math.min()? by Charlie Harvey</a></p><h1 id="sort-函数自动类型转换"><a href="#sort-函数自动类型转换" class="headerlink" title="sort() 函数自动类型转换"></a>sort() 函数自动类型转换</h1><p><code>sort()</code> 函数自动将值转换为字符串，这就会导致奇怪的事情发生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>].sort()</span><br><span class="line">(<span class="number">4</span>) [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>但是，它可以通过比较来解决:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a - b&#125;);</span><br><span class="line">(<span class="number">4</span>) [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BowyerWatson算法</title>
      <link href="/2019/11/29/Bowyer-Watson/"/>
      <url>/2019/11/29/Bowyer-Watson/</url>
      
        <content type="html"><![CDATA[<p>不规则三角网（Triangulated Irregular Network，TIN）在表示地形的形态方面具有较好的表现，其生成算法一直备受关注。Delaunay三角剖分生成的网格正则性好，因此在实际工程计算中应用很广。生成 Delaunay 三角网格的方法中，目前大都基于 Bowyer-Watson法，它是一种逐点插入法，基本思路是 ：先由给定的点集生成一初始网格，再根据 Delaunay 剖分原理，逐次向网格内加点 ,并重新连接生成新网格，直到所有点添加完毕。</p><p>下面我们就该算法的思路、步骤进行解析。</p><a id="more"></a><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h3><ol><li>假定已生成了连接若干个顶点的 Delaunay 三角网格</li><li>加入一个新的节点，找出所有外接圆包含新加入节点的三角形，并将这些三角形删除，形成一个空腔</li><li>空腔的节点与新加入的节点连接，形成新的 Delaunay 三角形网格</li><li>不断循环直到遍历完所有点</li></ol><p>示意图如下：</p><img src="https://img-blog.csdnimg.cn/20190525184106410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjczMzUw,size_16,color_FFFFFF,t_70" style="zoom:50%;" /><p><img src="https://img-blog.csdnimg.cn/20190525182457784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjczMzUw,size_16,color_FFFFFF,t_70" alt=""></p><p>通过上述思路我们总结出算法需要解决的几大问题：</p><ol><li>初始格网的生成</li><li>新增点所影响三角形的查找</li><li>空腔的生成</li></ol><p>下面我们就这些问题提出解决方法。</p><p>我们可以通过显示窗口的四个顶点来生成<em>包含所有离散点</em>的两个三角形，算法结束后删除就好，如图</p><p><img src="https://img-blog.csdnimg.cn/20190525183315707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjczMzUw,size_16,color_FFFFFF,t_70" alt=""></p><p>而外接圆包含新增点的三角形，这里我们称为坏三角形，坏三角形的查找是本算法的核心。</p><p>一般来说，如果采用暴力遍历的方法，随着算法后面三角格网的复杂度不断增加，坏三角形的查找也会变得越来越困难。所以我们希望可以有方法加速这一进程，但这里我们不做讨论，因为我没有实际运用。没错我的算法很暴力。</p><p>那么问题来了，新增点的坏三角形可能不止一个，如果要一直遍历出所有坏三角，就算是我也没暴力到这种程度。</p><p>这里我们发现，如果一个三角形是坏三角，那么它邻接的三角肯定有两个也是坏三角。那么我们可以通过构建一个三角形邻接表，找到一个坏三角就等于找到了一圈坏三角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">self.coords.append(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算外接圆包括p点的三角（坏三角形）</span></span><br><span class="line">bad_triangles = []</span><br><span class="line"><span class="keyword">for</span> T <span class="keyword">in</span> self.triangles:</span><br><span class="line">    <span class="comment"># 距离跟半径的比较</span></span><br><span class="line">    <span class="keyword">if</span> self.inCircle(T, p):</span><br><span class="line">        bad_triangles.append(T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空腔边缘。</span></span><br><span class="line">boundary = []</span><br><span class="line">T = bad_triangles[<span class="number">0</span>]</span><br><span class="line">edge = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 检查三角形T的边缘是否在boundary里...</span></span><br><span class="line">    tri_op = self.triangles[T][edge]</span><br><span class="line">    <span class="keyword">if</span> tri_op <span class="keyword">not</span> <span class="keyword">in</span> bad_triangles:</span><br><span class="line">        boundary.append((T[(edge+<span class="number">1</span>) % <span class="number">3</span>], T[(edge<span class="number">-1</span>) % <span class="number">3</span>], tri_op))</span><br><span class="line">        edge = (edge + <span class="number">1</span>) % <span class="number">3</span></span><br><span class="line">        <span class="comment"># 是否找完一圈</span></span><br><span class="line">        <span class="keyword">if</span> boundary[<span class="number">0</span>][<span class="number">0</span>] == boundary[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 下一条边</span></span><br><span class="line">        edge = (self.triangles[tri_op].index(T) + <span class="number">1</span>) % <span class="number">3</span></span><br><span class="line">        T = tri_op</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete删除，删出一个空洞</span></span><br><span class="line"><span class="keyword">for</span> T <span class="keyword">in</span> bad_triangles:</span><br><span class="line">    <span class="keyword">del</span> self.triangles[T]</span><br><span class="line">    <span class="keyword">del</span> self.circles[T]</span><br></pre></td></tr></table></figure><p>代码中boundary即是图中绿色空腔边缘。删掉所有坏三角形成空腔，再通过空腔边缘与新增点形成新的三角格网完成更新，当然不要忘了更新各种附加数据。</p><img src="https://img-blog.csdnimg.cn/20190525190154662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjczMzUw,size_16,color_FFFFFF,t_70" style="zoom:50%;" /><p>最终效果图如下，右方的括号内是三角形顶点点号</p><p><img src="https://img-blog.csdnimg.cn/20190525190910140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjczMzUw,size_16,color_FFFFFF,t_70" alt=""></p><p>源码地址：<a href="https://github.com/UI-Mario/Create-TIN" target="_blank" rel="noopener">https://github.com/UI-Mario/Create-TIN</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity打包android步骤</title>
      <link href="/2019/11/28/unity%E6%89%93%E5%8C%85android/"/>
      <url>/2019/11/28/unity%E6%89%93%E5%8C%85android/</url>
      
        <content type="html"><![CDATA[<p>因为最近打算把很久之前写的unity小游戏移植到移动端，所以写了这篇操作步骤。</p><p>首先安卓环境配置</p><h2 id="1-选择edit-gt-preference，再选择external-tools"><a href="#1-选择edit-gt-preference，再选择external-tools" class="headerlink" title="1.选择edit-&gt;preference，再选择external tools"></a>1.选择edit-&gt;preference，再选择external tools</h2><p><img src="https://ftp.bmp.ovh/imgs/2019/11/f6c3234b157d25ac.jpg" alt="img"></p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/a2f8820f014c2b57.jpg" alt="img"></p><a id="more"></a><h2 id="2-我们现在需要两个文件夹，JDK和SDK（红圈，路径不含中文），NDK没必要。"><a href="#2-我们现在需要两个文件夹，JDK和SDK（红圈，路径不含中文），NDK没必要。" class="headerlink" title="2.我们现在需要两个文件夹，JDK和SDK（红圈，路径不含中文），NDK没必要。"></a>2.我们现在需要两个文件夹，JDK和SDK（红圈，路径不含中文），NDK没必要。</h2><p>点击JDK和SDK后面的download会弹出网页让你下载，不过有点小小的障碍。</p><p>SDK：会通过android studio让你下载SDK包，没错就是装android studio的过程中下载SDK包，记住你SDK下载的位置就行，然后点browse找到你的SDK文件夹，JDK道理一样。</p><p>JDK：JAVA SE 9不能用，具体什么原因我也忘了，下载JAVA8.*的JDK</p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/c09776604177c2dd.jpg" alt="img"></p><h2 id="3-添加环境变量，这个过程比较繁琐，推荐网页：unity3d配置Android环境，打包发布Apk流程详解"><a href="#3-添加环境变量，这个过程比较繁琐，推荐网页：unity3d配置Android环境，打包发布Apk流程详解" class="headerlink" title="3.添加环境变量，这个过程比较繁琐，推荐网页：unity3d配置Android环境，打包发布Apk流程详解"></a>3.添加环境变量，这个过程比较繁琐，推荐网页：<a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/3c67fbfbb67c">unity3d配置Android环境，打包发布Apk流程详解</a></h2><p>然后我们开始打包，选择file-&gt;build setting，选中安卓，点击playersetting</p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/9c654ea62f44a0ae.jpg" alt="img"></p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/955721274c15a031.jpg" alt="img"></p><p>这里面很多发布的设置，可以自己慢慢去摸索，但打包安卓有几点必须清楚：</p><p>改掉other setting里面的packagename，像我上面改的，</p><p>然后安卓版本也可以自己选，不超过你手机安卓版本就行，一般6.0,7.0</p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/c57acd74e35bd457.jpg" alt="img"></p><p>然后就开始打包build，记得gradle改成internal，就完成了。</p><p><img src="https://ftp.bmp.ovh/imgs/2019/11/50020c02fc1dc342.jpg" alt="img"></p><p>这里说一下如果想要做安卓游戏记得找安卓游戏教程，不是每个游戏都能打包成安卓在手机上玩的，涉及到代码和虚拟操作键等。</p><p>附游戏地址：<a href="https://github.com/UI-Mario/unity-learn-mario" target="_blank" rel="noopener">https://github.com/UI-Mario/unity-learn-mario</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEEE754</title>
      <link href="/2019/11/27/js%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/11/27/js%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>初学JavaScript，在进行浮点数运算时，经常会碰到这样的情况：<code>0.1 + 0.2=0.30000000000000004</code>，这是比较著名的，看这个网站你就知道有多著名了<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a></p><p>还有以下其他的坑：</p><p><code>1000000000000000128 === 1000000000000000129</code></p><p><code>0.7*180=125.99999999998</code></p><p>为了避免这类问题出现在在实际生产过程中，我们希望搞清楚这是什么导致的，又该怎样去规避。</p><a id="more"></a><h1 id="IEEE-754-Floating-point"><a href="#IEEE-754-Floating-point" class="headerlink" title="IEEE 754 Floating-point"></a>IEEE 754 Floating-point</h1><p>众所周知，<strong>计算机是采用二进制来表示十进制的</strong>，二进制的规则是：<u>整数除以2，商继续除以2，得到0为止，将余数逆序排列；小数乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列</u></p><p>而我们浮点数有一些特点，例如：</p><ol><li><p>在同等位数的情况下，浮点数可表示的数值范围比整数的大；</p></li><li><p>浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法<strong>m*2e</strong>表示的数值而已；（如0.5的科学计数法是$1*2^{-1}$，则可被精确存储；而0.2则无法被精确存储）</p></li><li><p>浮点数不仅可表示有限的实数，还可以表示有限的整数。</p></li></ol><p>导致<code>0.1+0.2!==0.3</code>的，就是我们的第二点。</p><p>因为根据前面介绍的知识，0.1 的二进制表示为：</p><p><code>0.1 = 2^-4 * 1.10011(0011)// (0011) 表示循环</code></p><p>0.2 的二进制表示为：</p><p><code>0.2 = 2^-3 * 1.10011(0011)// (0011) 表示循环</code></p><p>0.1和0.2他俩的二进制都无限循环，而我们JS的Number数值类型，采用的是IEEE 754（64位）双精度浮点数编码，64位中符号位占一位，整数位占11位，其余52位都为小数位。所以0.1和0.2的小数位末尾需要判断是否进位（规则和十进制里的四舍五入一样）。</p><blockquote><p>IEEE 754 标准是IEEE浮点数算术标准(IEEE Standard for Floating-Point Arithmetic)的标准编号 ，等同于国际标准ISO/IEC/IEEE 60559 。IEEE 754 标准规定了计算机程序设计环境中的二进制和十进制的浮点数之间的交换、算术格式以及方法 。</p></blockquote><p>所以 0.1的二进制表示（<code>0.1 = 2^-4 * 1.10011(0011)</code>） 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code>，同理可得0.2的二进制表示 。把这两个二进制加起来得到 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值再换算成十进制就是 <code>0.30000000000000004</code>。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>到这里我们都理解只要采取IEEE 754 FP的浮点数编码的语言均会出现上述问题，现在我们希望可以规避这个坑。</p><p>若需要复杂且严禁的运算功能，推荐<a href="https://github.com/MikeMcl/decimal.js/" target="_blank" rel="noopener">https://github.com/MikeMcl/decimal.js/</a></p><p>ref：阮一峰：<a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p><h1 id="Number延展知识"><a href="#Number延展知识" class="headerlink" title="Number延展知识"></a>Number延展知识</h1><h2 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h2><ul><li>调用Math</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(num);</span><br></pre></td></tr></table></figure><ul><li>位运算</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1.23</span></span><br><span class="line"><span class="keyword">let</span> num1 = num | <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>取反操作符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~num  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.ceil(num)</span><br></pre></td></tr></table></figure><h2 id="保留小数点有效位数"><a href="#保留小数点有效位数" class="headerlink" title="保留小数点有效位数"></a>保留小数点有效位数</h2><p>1.toFixed()：这个函数目前浏览器都支持得比较好，但它的小数部分是定长的，不会因为后面是0就自动舍弃掉，会出现1.00，3.50这样的数据</p><p>2.Math.round(x * 100) / 100;不会补0</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS:深拷贝&amp;浅拷贝</title>
      <link href="/2019/11/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/11/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>拷贝，我们常常用在把A对象的属性copy到B对象，这样B对象就拥有了A对象的属性。当B对象的属性不是<em>基本数据类型</em>，而是数组或者对象的时候，就会出现浅拷贝和深拷贝的区别。</p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>当B对象的属性是数组或者对象的时候，浅拷贝是通过使A对象的同名属性指向B对象的属性的内存地址，从而达到copy的目的。这样的做法会造成一个问题，当我们改变B对象这个属性时，A对象的这个属性也会被改变，因为它们是指向同一段内存地址的。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>与浅拷贝相对应，当源对象的属性是一个对象或者数组时，深拷贝会为目标对象开辟一段新的内存地址，然后把源对象属性的值一一拷贝到目标对象，而不是直接使二者指向同一段内存地址。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>写到这里觉得有必要提一下数据类型，在js中，数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。</p><ul><li>基本数据类型的特点：直接存储在栈(stack)中的数据。</li><li>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里。</li></ul><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p><img src="https://ftp.bmp.ovh/imgs/2019/11/e92bac5084e6d6b9.jpeg"><a id="more"></a># 实现<p>浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">origin, destination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.hasOwnProperty(i)) &#123;</span><br><span class="line">            destination[i] = origin[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝</p><p>1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(copyObj))</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">origin, destination</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> origin[i] === <span class="string">'object'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(origin[i].constructor === <span class="string">'Array'</span>)&#123;</span><br><span class="line">                destination[i] = [];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                destination[i] = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            deepCopy(origin[i], destination[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            destination[i] = origin[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-箭头函数</title>
      <link href="/2019/11/16/ES6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2019/11/16/ES6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="箭头函数没有arguments"><a href="#箭头函数没有arguments" class="headerlink" title="箭头函数没有arguments"></a>箭头函数没有arguments</h2><p>箭头函数不仅没有this，常用的arguments也没有。如果你能获取到arguments，那它一定是来自父作用域的。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// 1，2</span></span><br></pre></td></tr></table></figure><p>arguments转化为真数组：</p><ol><li><p>slice</p><p>arguments 对象不支持数组的其他方法，但是可以用 Function.call 来间接调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="string">"bonjour"</span>)  <span class="comment">//["hello", "你好", "bonjour"]</span></span><br></pre></td></tr></table></figure></li><li><p>splice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="string">"bonjour"</span>)  <span class="comment">//["hello", "你好", "bonjour"]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.from</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="string">"bonjour"</span>)  <span class="comment">//["hello", "你好", "bonjour"]</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">...arguments</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="string">"bonjour"</span>)  <span class="comment">//["hello", "你好", "bonjour"]</span></span><br></pre></td></tr></table></figure></li></ol><p>在严格模式和非严格模式中，arguments 的表现显示不相同。</p><p>至于arguments有什么用呢，在我目前所接触的应用场景中，每个arguments对象都有两个额外的属性：arguments.callee和arguments.caller。前者指向使用该arguments对象被调用的函数。后者指向调用该arguments对象的函数。</p><p>其中arguments.callee除允许匿名函数递归调用自身（意思就是递归函数本来函数名跟这个函数是绑在一起的，arguments.callee可以做到让其他函数调用这个递归函数）</p><h2 id="不能使用new"><a href="#不能使用new" class="headerlink" title="不能使用new"></a>不能使用new</h2><h2 id="可以和变量解构结合使用"><a href="#可以和变量解构结合使用" class="headerlink" title="可以和变量解构结合使用"></a>可以和变量解构结合使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> full(&#123;<span class="attr">first</span>: <span class="number">1</span>, <span class="attr">last</span>: <span class="number">5</span>&#125;) <span class="comment">// '1 5'</span></span><br></pre></td></tr></table></figure><h2 id="没有prototype"><a href="#没有prototype" class="headerlink" title="没有prototype"></a>没有prototype</h2>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-属性简写</title>
      <link href="/2019/11/16/ES6-%E5%B1%9E%E6%80%A7%E7%AE%80%E5%86%99/"/>
      <url>/2019/11/16/ES6-%E5%B1%9E%E6%80%A7%E7%AE%80%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript6使得声明对象字面量更加简单，提供了属性简写和方法简写功能，属性名计算的新特性。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name, age, weight</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 如果属性名和属性值同名可以利用、es6的属性简写</span></span><br><span class="line">        name,  <span class="comment">// 等同于 make: make</span></span><br><span class="line">        age, <span class="comment">// 等同于 model: model</span></span><br><span class="line">        weight, <span class="comment">// 等同于 value: value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ES6的属性名是可计算的</span></span><br><span class="line">        [<span class="string">'over'</span> + weight]: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象方法名简写可以省略 function 关键字</span></span><br><span class="line">        descripte() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(name, age, weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = getInfo(<span class="string">'Kia'</span>, <span class="number">27</span>, <span class="number">400</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);<span class="comment">// &#123;name: "Kia", age: 27, weight: 400, over400: true, descripte: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>如果可以理解上述三个新特性，可以不必往下阅读。下面的文字仅提供给还有疑问的朋友。</p><h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><p>在 ES5及以前的版本中，对象字面量只支持键值对集合。实际业务中，对象字面量的初始化会有一定的代码重复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPeople</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPeople</code>函数用来创建一个People的对象，可以看到上面的代码的 <code>name</code>和<code>age</code>分别书写了两次，有些麻烦。在ES6中通过使用属性简写特性可以消除这种属性名称和局部变量之间的重复书写,当对象的属性和变量同名时，可以不必再写冒号和值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPeople</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法名简写"><a href="#方法名简写" class="headerlink" title="方法名简写"></a>方法名简写</h2><p>ES5中若为对象添加方法必须指定方法名称，并完整地定义函数来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = &#123;</span><br><span class="line">    name: <span class="string">'xixi'</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6的语法更简洁，消除了冒号和方法名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = &#123;</span><br><span class="line">    name: <span class="string">'xixi'</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">people.sayName();<span class="comment">// xixi</span></span><br></pre></td></tr></table></figure><h2 id="属性可计算"><a href="#属性可计算" class="headerlink" title="属性可计算"></a>属性可计算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastName = <span class="string">'last name'</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [lastName]: <span class="string">'yuan'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]);<span class="comment">// yuan</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-解构赋值</title>
      <link href="/2019/11/16/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2019/11/16/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>数组的解构赋值是基于数组位置的，比如：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">// 结果a等于1，b等于2</span></span><br></pre></td></tr></table></figure><p>也可以通过解构改变变量的值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[a,b] = [<span class="number">100</span>, <span class="number">200</span>];</span><br></pre></td></tr></table></figure><p>当=左边与右边不完全匹配时，未能匹配到的变量会被赋值为undefined,比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//a为1，b为2，c为undefined</span></span><br></pre></td></tr></table></figure><p>所以可以通过给一些变量指定默认值，以防止这种情况的发生。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c=<span class="number">3</span>] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//a==1, b==2, c==3</span></span><br></pre></td></tr></table></figure><p>注意：只有当在右边找不到对应的值或值为undefined时，才会使用默认值。</p><p>有时候，解构赋值中，你可能只关心一部分数据，这时可以通过占位符只给某些值赋值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,,b,,] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] <span class="comment">//a==1 b==4</span></span><br></pre></td></tr></table></figure><p>在解构赋值中，通过在变量前加…号，表示生成的变量为一个数组。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment">//a == 1, b==[3,4,5]</span></span><br></pre></td></tr></table></figure><p>上面展示的情况都是可以联合使用的,比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b=<span class="number">8</span>,,..c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">//a==1 b==2 c=[4,5,6]</span></span><br></pre></td></tr></table></figure><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对象的解构赋值是基于属性的。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = &#123;</span><br><span class="line">    name: <span class="string">'icode007'</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name == 'icode007' age==27</span></span><br></pre></td></tr></table></figure><p>与数组的解构赋值一样，对象的解构赋值一样给未能解构的变量赋值undefined，一样可以使用默认值。</p><p>当给已存在的变量解构赋值时，注意加()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line">(&#123;name, age&#125; = &#123;<span class="attr">name</span>: <span class="string">'icode007'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;);</span><br></pre></td></tr></table></figure><p>这是由于如果不加(),js会把左边看成一个代码块，会报错。 加了()后，整个变成了一个合法的表达式。</p><p>在上面的解构赋值中，<em>变量名和对象中的属性名必须相同</em>，只有这样，才能找到对应的要解构赋值的数据。<br>但如果我们想要给数据赋一个不同的名字呢？ 也是有办法的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myName, <span class="attr">age</span>: myAge&#125; = &#123;<span class="attr">name</span>: <span class="string">'icode007'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure><p>这样相应的名字和年龄就被赋值给myName和myAge了。</p><p>也可以同时使用默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myName, <span class="attr">age</span>: myAge, <span class="attr">jog</span>: myJob = <span class="string">'soft Engineer'</span>&#125; = &#123;<span class="attr">name</span>: <span class="string">'icode007'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure><p>以上我们列举的对象的解构赋值的例子都非常的简单，但在实际开发中，JSON数据可能是非常复杂的，这时的解构赋值语法也可能变得复杂。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123; start &#125;&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start.line);</span><br><span class="line"><span class="built_in">console</span>.log(start.column);</span><br></pre></td></tr></table></figure><p>注意：每当有:出现在解构赋值中时，:左边的标识符表示要检查的位置，右边表示要赋值的目标，如果右边是{}或[]时，表示要赋值的变量在更深层次结构中。</p><p>上面的所有实例，如默认值，变量更名等特性都可能存在于一个解构赋值语句中。并且，数组的解构赋值与对象的解构赋值，也可以混合使用。这为我们从复杂的数据结构中提取相应数据提供了极大的便利。</p><h3 id="函数参数的解构"><a href="#函数参数的解构" class="headerlink" title="函数参数的解构"></a>函数参数的解构</h3><p>函数参数的解构功能对于实现多参的函数是非常有用的。<br>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>)</span>&#123;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> secure = option.secure,</span><br><span class="line">        path = option.path,</span><br><span class="line">        domain = option.domain</span><br><span class="line">    ;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">'type'</span>, <span class="string">'js'</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>上面的函数是常用的实现多参函数的方式，name, value为必填参数，所有可选参数封装到options中，作为options的属性使用。<br>但上面的函数存在一个问题就是，你只看函数的定义，是无法知道到底可选参数的名称是什么的？你需要阅读函数代码，了解函数才能使用它。</p><p>使用函数参数解构则直观很多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123;secure, path, domain&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用同样的使用方式可以调用这个函数。</p><p>但是这种写法有种问题是当只传入name和value参数时，会报错。</p><p>更好的写法是使用函数的默认参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123;secure, path = <span class="string">"/"</span>, domain&#125; = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>数组的解构赋值中，使用…rest的变量必须放在最后。</li><li>与普通的变量的赋值语句一样，解构赋值语句也是有值的，它的值就是=右边的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS:this指向</title>
      <link href="/2019/11/15/JS:this%E6%8C%87%E5%90%91/"/>
      <url>/2019/11/15/JS:this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="THIS常用场景"><a href="#THIS常用场景" class="headerlink" title="THIS常用场景"></a>THIS常用场景</h1><h2 id="1、以函数形式调用-this指向window"><a href="#1、以函数形式调用-this指向window" class="headerlink" title="1、以函数形式调用,this指向window"></a>1、以函数形式调用,this指向window</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">m,n</span>)</span>&#123;</span><br><span class="line">   m=<span class="number">2</span>;</span><br><span class="line">   n=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.m,n);<span class="comment">//undefined,this指向了window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>严谨来说，当fn()是直接使用不带任何修饰的函数引用进行调用的，则默认绑定到全局对象上，浏览器里就是<code>window</code>；但是在<code>use strict</code>的情况下就是<code>undefined</code>。</p><a id="more"></a><h2 id="2、以方法形式调用-this指向调用方法的那个对象"><a href="#2、以方法形式调用-this指向调用方法的那个对象" class="headerlink" title="2、以方法形式调用,this指向调用方法的那个对象"></a>2、以方法形式调用,this指向调用方法的那个对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"red"</span>; <span class="comment">//this指向box,box颜色为红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、构造函数调用-this指向实例的对象"><a href="#3、构造函数调用-this指向实例的对象" class="headerlink" title="3、构造函数调用,this指向实例的对象"></a>3、构造函数调用,this指向实例的对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age , name </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.a = age ;</span><br><span class="line">   <span class="keyword">this</span>.b = name;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// 此处 this 分别指向 Person 的实例对象 p1 p2 </span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">'zs'</span>)</span><br><span class="line">   <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">'ww'</span>)</span><br><span class="line"> 控制台输出:</span><br><span class="line"> Person &#123;<span class="attr">a</span>: <span class="number">18</span>, <span class="attr">b</span>: <span class="string">"zs"</span>&#125;</span><br><span class="line"> Person &#123;<span class="attr">a</span>: <span class="number">18</span>, <span class="attr">b</span>: <span class="string">"ww"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4、使用window对象的方法时-指向window"><a href="#4、使用window对象的方法时-指向window" class="headerlink" title="4、使用window对象的方法时,指向window"></a>4、使用window对象的方法时,指向window</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box =<span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">box.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.style.backgroundColor=<span class="string">"yellow"</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错,因为setTimeout是window的一个方法.</span></span><br></pre></td></tr></table></figure><p>更改错误,使box颜色为yellow</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box =<span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">box.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>;<span class="comment">//box调用了这个方法,此时的this指向box,此操作将指向box的this赋给me,则得到的me的指向为指向this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       me.style.backgroundColor=<span class="string">"yellow"</span><span class="comment">//此时的me.style就指的是box的style</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、多重场景改变this指向"><a href="#5、多重场景改变this指向" class="headerlink" title="5、多重场景改变this指向"></a>5、多重场景改变this指向</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">box.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     fn1(); <span class="comment">//事件触发了fn1,在函数内部,以函数形式调用this依旧指向window</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//事件处理函数中的this,该事件由谁触发,this就指向谁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6、箭头函数里的this"><a href="#6、箭头函数里的this" class="headerlink" title="6、箭头函数里的this"></a>6、箭头函数里的this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'obj'</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">       (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">       &#125;)()</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">//window</span></span><br><span class="line"> <span class="comment">//附：在quickjs引擎里是window，在node里是undefined，chrome浏   览器里居然也是window（node和chrome用的都是v8引擎）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数，由于闭包函数是window执行的，所以this指向window；</span></span><br><span class="line"><span class="comment">//箭头函数的this指向函数创建时的作用域。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'obj'</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">       (<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">//改成箭头函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">       &#125;)()</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">//改成箭头函数，后可以看出创建时的作用域是obj.fn函数执行是的作用域，也就是obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.fn;</span><br><span class="line">f();  <span class="comment">//就变成全局了</span></span><br></pre></td></tr></table></figure><h2 id="7、call、apply、bind改变this指向"><a href="#7、call、apply、bind改变this指向" class="headerlink" title="7、call、apply、bind改变this指向"></a>7、call、apply、bind改变this指向</h2><h1 id="修改THIS指向"><a href="#修改THIS指向" class="headerlink" title="修改THIS指向"></a>修改THIS指向</h1><h2 id="apply、call、bind用法"><a href="#apply、call、bind用法" class="headerlink" title="apply、call、bind用法"></a>apply、call、bind用法</h2><ul><li><p>apply:<br><strong>fn.apply(thisObj,数组参数）</strong><br>定义：应用某一个对象的一个方法，用另一个对象替换当前对象<br>说明：如果参数不是数组类型的，则会报一个TypeError错误。</p></li><li><p>call:</p><p><strong>fn.call(thisObj, arg1, arg2, argN)</strong><br>apply与call的唯一区别就是接收参数的格式不同。</p></li><li><p>bind:</p><p><strong>fn.bind(thisObj, arg1, arg2, argN)</strong><br>bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>apply</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply= <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;<span class="comment">//1.将函数挂载到传入的对象</span></span><br><span class="line">    <span class="keyword">var</span> arg = [...arguments].splice(<span class="number">1</span>)[<span class="number">0</span>];<span class="comment">//2.取参数</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arg)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'apply的第二个参数必须是数组'</span>) <span class="comment">//3.限制参数类型为数组</span></span><br><span class="line">    &#125;    </span><br><span class="line">    context.fn(arg) <span class="comment">//4.执行对象的方法</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn; <span class="comment">//5.移除对象的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,arr)</span><br><span class="line">&#125;</span><br><span class="line">sayName.myApply(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">//obj [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>call</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall= <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;<span class="comment">//1.将函数挂载到传入的对象</span></span><br><span class="line">    <span class="keyword">var</span> arg = [...arguments].splice(<span class="number">1</span>);<span class="comment">//2.取参数</span></span><br><span class="line">    context.fn(...arg) <span class="comment">//3.执行对象的方法</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn; <span class="comment">//4.移除对象的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'obj1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,...arguments)</span><br><span class="line">&#125;</span><br><span class="line">sayName.myCall(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>) <span class="comment">//obj1 1,2,3,5</span></span><br></pre></td></tr></table></figure><p>bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'被绑定的对象需要是函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : oThis, args.concat([].slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.prototype)&#123;</span><br><span class="line">        func.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使fBound.prototype是func的实例，返回的fBound若作为new的构造函数，新对象的__proto__就是func的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> func()</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN默认端口被占用</title>
      <link href="/2019/11/10/temp/"/>
      <url>/2019/11/10/temp/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Native-address-already-in-use-8081"><a href="#React-Native-address-already-in-use-8081" class="headerlink" title="React-Native:address already in use :::8081"></a>React-Native:address already in use :::8081</h1><p>最近在用react native开发一款app，但是在输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native run-android</span><br></pre></td></tr></table></figure><p>之后编译失败，弹出如下错误</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address already in use :::8081</span><br></pre></td></tr></table></figure><p>情况就是你的8081端口被占了，导致RN无法正常运行</p><p>所以这时候就有两种思路：干掉占端口的程序 or 换个端口号</p><p>第一种方法很简单，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i:8081</span><br></pre></td></tr></table></figure><p>查看占用该端口的应用，并找到其PID，利用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>杀死这个程序。例如我的端口就是被node占用，查看到node的pid是6478，那么直接sudo kill 6478就可以了。在很多情况下没法杀死这个进程时，你可能就得考虑一下更改RN的port。</p><p>更改port的情况我暂时没遇上，毕竟电脑也带不起多个RN，这里留下一些网址仅供参考</p><p><a href="https://yq.aliyun.com/articles/178871" target="_blank" rel="noopener">教你轻松修改React Native的端口</a></p><p><a href="https://zhuanlan.zhihu.com/p/53038329" target="_blank" rel="noopener">React Native: Port 8081 already in use…</a></p>]]></content>
      
      
      <categories>
          
          <category> 填坑 </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升和暂时性死区</title>
      <link href="/2019/11/05/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/"/>
      <url>/2019/11/05/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>js在解析上述代码时，实际上是按照如下方式进行解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>也就是js会先把所有变量都声明好了之后，然后才进行赋值，并不是声明一个变量就赋值，再声明一个再赋值。</p><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。另外，变量跟函数重名时，函数整体在变量整体后面。</p><p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS简史</title>
      <link href="/2019/11/01/js%E7%AE%80%E5%8F%B2/"/>
      <url>/2019/11/01/js%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="js简史"><a href="#js简史" class="headerlink" title="js简史"></a>js简史</h1><p>1994年10月，NCSA的一个主要程序员Marc Andreessen（就是讲浏览器历史里面的那位）联合风险投资家Jim Clark，成立了Mosaic通信公司（Mosaic Communications），不久后改名为Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器Netscape Navigator。并在同年12月，Navigator发布了1.0版。</p><a id="more"></a><img src="https://ftp.bmp.ovh/imgs/2019/10/f3885bd9ca3773b9.jpg" style="zoom:50%;" ><p>但很快Netscape 公司发现，浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。因为网速很慢上网很贵，有些操作不宜在服务端完成。而同年，Sun公司开发了Java语言，Netscape公司决定与Sun合作，但浏览器不必使用Java这样复杂的语言，因此开发了一款与Java接近且支持Java程序的语言。</p><p>1995年5月，Netscape公司雇佣了程序员Brendan Eich花10天开发这种网页脚本语言，希望开发出一个类似 Java 的脚本语言，用来提升浏览器的展示效果，增强动态交互能力。结果大佬喝着啤酒抽着烟，十来天就把这个脚本语言写出来了，功能很强大，就是语法一点都不像 Java。最初叫Mocha，9月更名为livescriplt，12月与Sun公司达成协议，叫Javascript。这样就渐渐形成了前端的雏形：HTML 为骨架，CSS 为外貌，JavaScript 为交互。</p><img src="https://ftp.bmp.ovh/imgs/2019/11/265d834a0b0a5054.jpeg" style="zoom:100%"><p>同时期微软等一些公司也针对自家浏览器开发出了自己的脚本语言。浏览器五花八门，虽然有了比较统一的 ECMA 标准，但是浏览器先于标准在市场上流行开来，成为了事实标准。导致，现在前端工程师还要在做一些政府古老项目的时候，还要去处理浏览器兼容（万恶的 IE 系列）。</p><p>ECMAScript版本：<br>1.ECMAScript第一版是根据Netscape发布的JavaScript1.1 指定的，本质上与JavaScript1.1相同， 只是删除了所有针对Netscape浏览器特有的代码，以及做了一些小改动</p><p>2.ECMAScript第二版主要是对第一版的编辑加工，没有做任何的新增，修改，删除</p><p>3.ECMAScript第三版才算是对ECMAScript的第一次真正修改，修改的内容涉及字符串处理，错误处理和数值输 出，这一版还新增了对正则表达式，控制语句等的支持</p><p>4.ECMAScript第四版因为改动太大而流产，同时出现了ECMAScript3.1的替代性提案</p><p>5.因为第四版流产，ECMAScript3.1作为了ECMAScript第5版发布，此版本新增了一些新功能，比如原生的JSON对象， 继承的方法，并且消除了第三版中存在的一些歧义</p><p>6.基于流产的第四版并且经过多年的重新打磨与完善，全新的ES2015年闪亮登场，从此ES开始改为以年份命名，比如现在的ES2016，ES2017。ES6是ES2015以及之后ECMAScript的统称。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System limit for number of file watchers reached</title>
      <link href="/2019/11/01/ubuntu%E5%88%87%E6%8D%A2%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
      <url>/2019/11/01/ubuntu%E5%88%87%E6%8D%A2%E5%A4%9A%E7%89%88%E6%9C%ACJDK/</url>
      
        <content type="html"><![CDATA[<p>sudo update-alternatives –config java</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器发展的掐架史</title>
      <link href="/2019/10/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AE%80%E5%8F%B2/"/>
      <url>/2019/10/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="划时代的Netscape"><a href="#划时代的Netscape" class="headerlink" title="划时代的Netscape"></a>划时代的Netscape</h1><p>1993年，马克·安德森（下图）发布Mosaic——“世界上最流行的浏览器”，它引发了1990年代的互联网热潮。接着他辞职并成立了自己的公司——Netscape，发布了受Mosaic影响的Netscape Navigator。Netscape Navigator很快便成为世界上最流行的浏览器，市占率一度达到90%。</p><img src="https://ftp.bmp.ovh/imgs/2019/10/f3885bd9ca3773b9.jpg" style="zoom:50%;" ><p>那个时候还没有js、MVC模式之类的，每一个交互，按钮点击、表单提交，都需要等待浏览器响应很长时间，然后重新下载一个新页面。</p><a id="more"></a><p><img src="https://ftp.bmp.ovh/imgs/2019/10/4e46c91654db55ca.jpeg" alt=""></p><h1 id="第一轮浏览器大战"><a href="#第一轮浏览器大战" class="headerlink" title="第一轮浏览器大战"></a>第一轮浏览器大战</h1><div style="text-align:center"><img src="https://ftp.bmp.ovh/imgs/2019/10/3f0318d95623d813.png" alt="netscape" style="zoom:73%;" /><img src="https://ftp.bmp.ovh/imgs/2019/10/b8f162b815f18e36.png" alt="ie" style="zoom:83%;" /></div>如果不是网景浏览器的太过成功，或许不会有后来的IE了，快速的发展让Netscape犯下了一个致命错误，由于浏览器的成功带来的自信导致这家公司干脆尝试去做一个操作系统了，而当时操作系统领域已经领先的微软马上意识到网景的威胁，微软公司急忙买了Spyglass公司的技术，发布Internet Explorer，这引发了第一轮浏览器大战。<p>1997年微软基于Mosaic代码修改成了新的<strong>Trident内核</strong>，开发出了Internet Explorer，而且微软把IE浏览器捆绑在了他自己的操作系统中。在 1997 年，微软将 IE 预装到Windows中，这受到了无数人的反对与指责，并长期受到了政府的反垄断调查。但就结果而言，由于大多数用户并不了解其他的浏览器，而 Windows 又占据了绝大多数的市场份额，微软通过捆绑销售轻而易举的赢得了这场战斗，其市占率于2002年达到最高时超过95%。就这样，mosaic被IE干翻在地，开发者们迎来了一个‘崭新’的时代。</p><p>所幸的是现在这个从出世起就饱受争议的浏览器已经被淘汰掉了，微软推出了Edge。Edge 就是一个全新的开始——新名字，推倒重来的代码，以及全新的 CEO。</p><h1 id="Netscape的继承者：Mozilla"><a href="#Netscape的继承者：Mozilla" class="headerlink" title="Netscape的继承者：Mozilla"></a>Netscape的继承者：Mozilla</h1><p>1998年1月，网景与微软IE浏览器竞争失利以后，为了挽回市场，网景通信公司公布旗下所有软件以后的版本皆为免费，并成立了非正式组织Mozilla，自此Mozilla浏览器开始登上舞台。</p><p>讲到这里就得讲讲浏览器<strong>内核</strong>了。</p><p>浏览器内核英文叫做：Rendering Engine，内核可以分成两部分：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。目前主要有5大浏览器4大内核：</p><img src="https://ftp.bmp.ovh/imgs/2019/10/fe563c8e74aa8beb.png" style="zoom: 80%;" /><ul><li>Trident内核：IE</li><li>Gecko内核：Firefox</li><li>WebKit内核：Safari</li><li>Blink内核：Chrome（现在），Opera（现在）</li></ul><p>那个时候Trident内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大。</p><p>So，不知道是不是这个原因，微软很长时间都并没有更新Trident内核，这也导致了后面的两个后果： 一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox和Opera就在这个时候兴起了。</p><p>而那些不满的部分微软“叛将”与当时已经停止更新了的 Netscape 的一些员工一起创办了Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。针对IE，Gecko祭出了自己的杀手锏——开源，通过源代码开放，彻底解决了安全和速度问题。尤其是热代码加速这个全新思路，仿佛为Firefox打开了胜利之门。事实上，Firefox 1.0于2004年发表，不巧的是，Safari2003年发布测试版。</p><h1 id="Safari的崛起"><a href="#Safari的崛起" class="headerlink" title="Safari的崛起"></a>Safari的崛起</h1><p>勤劳的又追求极致的苹果推出的基于WebKit内核的Safari浏览器则引导了浏览器的本质回归潮流。Safari 在 2003 年 1 月 7 日首度发行测试版，并成为 Mac OS X v10.3 与之后版本的默认浏览器，也成为苹果其它系列产品的指定浏览器（也已支持 Windows 平台）。WebKit内核则是苹果基于KDE小组（Linux桌面系统）的 KHTML 引擎开发出来的，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为相比Gecko，KHTML 拥有清晰的源码结构和极快的渲染速度，也实现了<strong><em>JavaScript</em></strong>脚本的快速解释器调用。事实上，这个宝押对了。这种轻灵随后就赢得了Google的青睐（2008 年谷歌公司发布 chrome 浏览器，采用的 chromium 内核便 fork 了Webkit）。现在Google Chorme已成增长最快，<em>最受开发者喜欢的浏览器了</em>，加上苹果Safari的份额，WebKit已经与Gecko、Trident开始“三国演义”。</p><p>其实相比于Safari，大部分群众更乐意看见苹果和微软==也就是乔布斯和盖茨之间的相爱相杀。</p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/112595886f3f38e8.jpg" alt=""></p><p>盖茨和乔布斯并不总是剑拔弩张的敌人关系。微软也曾为非常受欢迎的 Apple II 开发软件，盖茨还会定期飞到库比提诺去看苹果都在搞什么。80 年代初期，乔布斯还会飞去华盛顿，和盖茨谈判，让微软给苹果 Macintosh 及其革命性图形用户界面开发软件。</p><p>但是1985 年微软发布第一个版本 Windows 时，乔布斯和盖茨的关系开始恶化。</p><p>原因就是乔布斯认为盖茨抄袭了苹果，但盖茨才不在乎，他知道图形用户界面以后会发展壮大，这种创意并不会成为苹果独家所有。两人之间的关系大概是这样：</p><p>乔布斯：盖茨和微软抄袭了 Macintosh！！！</p><p>盖茨：好吧，史蒂夫，我想我们可以从其他角度来看这个事情。我觉得事情更像是，我们都有一个名为施乐的富豪邻居，我闯进他家想偷电视的时候却发现，电视已经被你偷走了。（邻居指的是指的是Xerox PARC（Xerox Palo Alto Research Center，简称Xerox PARC）即施乐帕克研究中心）</p><p>乔布斯：盖茨没有一点廉耻之心，完全抄袭了我们的产品。</p><p>盖茨：他要是真这么觉得，那他确实是进入了他自己的现实扭曲力场中。</p><p>乔布斯认为盖茨深陷泥潭，太专注于做生意了。“更年轻的时候，要是他嗑药或者去寺院修行，他会成为更伟大的人。”</p><p>盖茨觉得乔布斯是个“彻头彻尾的怪人”，是一个“存在古怪缺陷的人”。</p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/b2fdf5769f811287.jpeg" alt="你瞅啥"></p><p>1985 年乔布斯离开苹果，建立 NeXT。虽然乔布斯离开了微软最大的竞争对手，没有继续在苹果工作，但两个人的关系也没有因此好转。</p><p>如果 NeXT 失败，微软 Windows 在竞争中胜出，乔布斯认为“我们会进入一个时长大约 20 年的计算机黑暗年代。”</p><p>就本文而言，真是神预言。</p><h1 id="Chrome：带动国内浏览器的发展"><a href="#Chrome：带动国内浏览器的发展" class="headerlink" title="Chrome：带动国内浏览器的发展"></a>Chrome：带动国内浏览器的发展</h1><p>Google希望通过Chrome浏览器来促进Web技术的发展，从而让自己受益，这也不是什么秘密，Chrome团队的人都是这么说的，Google现在的CEO是Sundar Pichai，他当年发布Chrome的时候是<a href="https://googleblog.blogspot.com/2008/09/fresh-take-on-browser.html" target="_blank" rel="noopener">这样说的</a>：</p><blockquote><p>We hope to collaborate with the entire community to help drive the web forward.</p></blockquote><p>这样假大空的话当年大概没几个人相信，但是这不重要，重要的是Google真的做到了，Chrome确实推动了Web技术的发展。没有Chrome的话，现在的Web技术大概确实得落后不少。</p><p>如果Google只是想要一个搜索入口，它可以收购一个浏览器，或者基于开源浏览器套一个壳，做一下账户系统就够了，再通过Google网站进行推广。国内各个大厂的浏览器都是基于Chrome的开源版本Chromium实现的，某个浏览器甚至直接打包了Chrome的安装包。</p><p>既然Google想做的事情是推动Web技术发展，如果沿用旧的思想和技术的话，显然是做不到的。于是，他们设计了一个多进程的浏览器架构，重新写了一个性能彪悍的JavaScript引擎V8，后来又基于Webkit做了一个新的渲染引擎Blink。</p><p>不妨这样说，<strong>Google与国内的搜索引擎巨头们的还差一个Chrome浏览器</strong>。后者看到的是搜索流量带来的商业价值以及重新开发一个浏览器的巨大成本，而前者看到了Web技术发展对搜索引擎本身的长远价值。</p><p>2015年8月全球不同浏览器市场占有率统计（数据来自StatCounter）：</p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/f751e6bbac1df8f1.png" alt=""></p><p>自苹果推出的WebKit内核后，这种回归本质的轻灵受到了谷歌的青睐，2008年chrome横空出世。界面简洁、加载快速、数据安全等这些特点让chrome越来越受喜欢，甚至好过于苹果了。加之很多web开发者对其的追捧，最终使其市场份额逐步攀升，成为了后起之秀。</p><p>Chromium 问世后，带动了国产浏览器行业的发展。一些基于 chromium 的单核，双核浏览器如雨后春笋般拔地而起，例如：搜狗、360、QQ浏览器等等，无一不是套着不同的外壳用着相同的内核。</p><p>为什么要用双核呢？</p><p>中国市场，由于Firefox等浏览器在中国的市场份额极少，中文网页多是“IE标准”，用户暂时无法抛弃Trident内核，但他们又需要速度更快、更稳定的浏览体验。采用“多核”之后，这种矛盾迎刃而解。</p><p>从全球范围来看，多核未必蔚然成风，但在特殊的中国市场，这代表了潮流。</p><p>值得一提的是，在chrome发展壮大过程中，微软才意识到chrome开始对它逐步侵蚀自己的市场有了危机感，才开始频繁更新IE，2011年IE9发布，2012年IE10发布，2013年IE11发布，最后IE的代码实在适应不了新要求的web技术，就重新开发了一个名为“edge”的浏览器用来取代IE，但还是挡不住chrome成为市场份额第一的命运。在IE横行的那一段时间为了适应IE中国的大多数常用网站也不大符合互联网标准，也就是说如果用符合互联网标准的浏览器去解析这些网站，反而会不正常显示，可见IE坐头把交椅的那几年，却一直在误导和阻挠互联网的发展，悲哉啊。在此要向那些不断创新、不断完善、不断接纳新web技术的浏览器公司致敬，面对IE他们的市场份额不高，却仍然坚持着不断前进。</p><img src="https://ftp.bmp.ovh/imgs/2019/10/fb1cda8a79621af7.png"><p>参考文献：</p><p><a href="https://www.jianshu.com/p/db1b230e3415" target="_blank" rel="noopener">全面了解浏览器（内核）发展史</a></p><p><a href="https://segmentfault.com/a/1190000011418105" target="_blank" rel="noopener">主流浏览器发展史及其内核初探</a></p>]]></content>
      
      
      <categories>
          
          <category> temp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEST</title>
      <link href="/2017/09/07/test/"/>
      <url>/2017/09/07/test/</url>
      
        <content type="html"><![CDATA[<p>TEST</p><p>用于测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> try </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
