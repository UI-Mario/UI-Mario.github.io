# when

回溯算法**面向的问题**是：一个有限数量的所有可能方案。

例如：n个小朋友，发苹果有多少种发法啥的

就是要求出所有的，没有啥取巧，如果说能找出某种`f(i)=Fn(f(i-1))`，那就该去参考动态规划的思想了

所以网上比较多的形容：把问题的解空间转化成了**图或者树**的结构表示，然后使用**深度优先搜索**策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解

# whitch

> 为什么用树形结构

类似于平行宇宙吧，在某个时间点做出不同选择，就生成不同的平行宇宙。想象一下那幅画面，肯定就是树🌲了呀

每个节点都是一种选择，最后把满足条件的根结点的路径push进res（其余不满足的，当然就不push）

## question:遇到不push但是已经到了根结点，怎么回退？

这也就是所谓的剪枝，是一种思想吧，请先看下列模版

TODO:（为什么要用深度优先算法？答：我也不知道，感觉广度也行，回头看看）

先给个满足大部分回溯的模版：

```
// 给一个数组nums不含重复元素，求出所有排列组合
const getAllPosibility = (nums) => {
	const res = [];   // 结果
	const path = [];  // 一条路径
  let usedId = [];  // 辅助工具，已经添加过的id
  dfs(res, path, usedId, nums)
  return res;
}

const dfs = (res, path, usedId, nums) => {
	if(path.length === nums.length) {
		res.push([...path]);
		return;
	}
	// 核心代码
	for(var i=0;i<nums.length;i++) {
		if(usedId.includes(i)) continue;
		path.push(nums[i]);
		usedId.push(i);
		def(res, path, usedId, nums);
		
		// 重点，画圈圈，敲黑板
		path.pop()
		usedId.pop();
	}
}
```

上述代码的思想就是，遍历所有可能路径，只把符合预期的路径添加进res。

而遍历所有可能路径的关键就在于，

```
path.pop()
usedId.pop();
```

我们的思路是：某条路径走完了，接下来，回退一个节点，回退两个节点，挨个继续试

代码使用迭代（我直接列出所有可能性，包括某条路径的所有可能会退，然后选出合适的）：这个节点值设为i，接下来的子树就继续迭代；节点值可能为nums中没使用的任意一个，所以要循环一遍

# why



