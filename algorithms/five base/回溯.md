# when

回溯算法**面向的问题**是：一个有限数量的所有可能方案。

例如：n个小朋友，发苹果有多少种发法啥的

就是要求出所有的，没有啥取巧，如果说能找出某种`f(i)=Fn(f(i-1))`，那就该去参考动态规划的思想了

所以网上比较多的形容：把问题的解空间转化成了**图或者树**的结构表示，然后使用**深度优先搜索**策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解

# whitch

> 为什么用树形结构

类似于平行宇宙吧，在某个时间点做出不同选择，就生成不同的平行宇宙。想象一下那幅画面，肯定就是树🌲了呀

每个节点都是一种选择，最后把满足条件的根结点的路径push进res（其余不满足的，当然就不push）

## question:遇到不push但是已经到了根结点，怎么回退？

这也就是所谓的剪枝，是一种思想吧

TODO:（为什么要用深度优先算法？答：我也不知道，感觉广度也行，回头看看）

先给个满足大部分回溯的模版：

```
// 给一个数组nums不含重复元素，求出所有排列组合
const getAllPosibility = (nums) => {
	const res = [];   // 结果
	const path = [];  // 一条路径
  let usedId = [];  // 辅助工具，已经添加过的id
  def(res, path, usedId, nums)
  return res;
}

const dfs = (res, path, usedId, nums) => {
	if(path.length === nums.length) {
		res.push([...path]);
		return;
	}
	// 核心代码
	for(var i=0;i<nums.length;i++) {
		path.push(nums[i]);
		usedId.push(i);
		def(res, path, usedId, nums);
		path.pop()
		usedId.pop();
	}
}
```



# why



