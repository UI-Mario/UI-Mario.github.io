# computed属性&method方法

> 其实官网上解释得很清楚了，笔者只是进行归纳总结，[官方文档](https://ui-mario.github.io/2019/12/20/web缓存/[https://cn.vuejs.org/v2/guide/computed.html#计算属性缓存-vs-方法](https://cn.vuejs.org/v2/guide/computed.html#计算属性缓存-vs-方法))

就像官网上的例子，我们可以通过在表达式中调用方法来达到同样的效果：

**html**



```
<p>Reversed message: "{{ reversedMessage() }}"</p>
```



**js**



```
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

**js**



```
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

可以看出两种方式的最终结果确实是完全相同的

但是总结下来两者间的最主要差别就是：

**computed有缓存功能，methods没有**

So，缓存有什么用？

# web缓存

先简单介绍一下*web缓存*

> Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。

在Web应用领域，Web缓存大致可以分为以下几种类型：

## 数据库数据缓存

Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。

## 服务器端缓存

### 代理服务器缓存

代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等，这里不再详述。

### CDN缓存

CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。

## 浏览器端缓存/http缓存

浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。

## web应用层缓存

应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。

# 浏览器端缓存浅析

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

## 浏览器端缓存机制

[![浏览器缓存示意图](https://s2.ax1x.com/2019/12/20/QOMBes.png)](https://s2.ax1x.com/2019/12/20/QOMBes.png)

[浏览器缓存示意图](https://s2.ax1x.com/2019/12/20/QOMBes.png)



（图片来自https://github.com/ljianshu/Blog）

### 按缓存位置分类：（留待更新）

#### Service Worker

#### Memory Cache

#### Disk Cache

#### Push Cache

### 按失效策略分类：

（先验知识：http协议、报文、缓存相关请求响应头等）

#### 强制缓存

#### 协商缓存

## 浏览器端缓存的控制

Web开发者可以在HTML页面的节点中加入标签，代码如下：

**plain**



```
<meta http-equiv="Pragma" content="no-cache">
```

上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。

