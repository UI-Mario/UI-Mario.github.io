初学JavaScript，在进行浮点数运算时，经常会碰到这样的情况：`0.1 + 0.2=0.30000000000000004`，这是比较著名的，看这个网站你就知道有多著名了http://0.30000000000000004.com/

还有以下其他的坑：

```
1000000000000000128 === 1000000000000000129
0.7*180=125.99999999998
```

为了避免这类问题出现在在实际生产过程中，我们希望搞清楚这是什么导致的，又该怎样去规避。

# IEEE 754 Floating-point

众所周知，**计算机是采用二进制来表示十进制的**，二进制的规则是：整数除以2，商继续除以2，得到0为止，将余数逆序排列；小数乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列

而我们浮点数有一些特点，例如：

1. 在同等位数的情况下，浮点数可表示的数值范围比整数的大；
2. 浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法**m\*2e**表示的数值而已；（如0.5的科学计数法是1∗2−11∗2−1，则可被精确存储；而0.2则无法被精确存储）
3. 浮点数不仅可表示有限的实数，还可以表示有限的整数。

导致`0.1+0.2!==0.3`的，就是我们的第二点。

因为根据前面介绍的知识，0.1 的二进制表示为：

```
0.1 = 2^-4 * 1.10011(0011)// (0011) 表示循环
```

0.2 的二进制表示为：

```
0.2 = 2^-3 * 1.10011(0011)// (0011) 表示循环
```

0.1和0.2他俩的二进制都无限循环，而我们JS的Number数值类型，采用的是IEEE 754（64位）双精度浮点数编码，64位中符号位占一位，整数位占11位，其余52位都为小数位。所以0.1和0.2的小数位末尾需要判断是否进位（规则和十进制里的四舍五入一样）。

> IEEE 754 标准是IEEE浮点数算术标准(IEEE Standard for Floating-Point Arithmetic)的标准编号 ，等同于国际标准ISO/IEC/IEEE 60559 。IEEE 754 标准规定了计算机程序设计环境中的二进制和十进制的浮点数之间的交换、算术格式以及方法 。

所以 0.1的二进制表示（`0.1 = 2^-4 * 1.10011(0011)`） 进位后就变成了 `2^-4 * 1.10011(0011 * 12次)010`，同理可得0.2的二进制表示 。把这两个二进制加起来得到 `2^-2 * 1.0011(0011 * 11次)0100` , 这个值再换算成十进制就是 `0.30000000000000004`。

# Solution

到这里我们都理解只要采取IEEE 754 FP的浮点数编码的语言均会出现上述问题，现在我们希望可以规避这个坑。

若需要复杂且严禁的运算功能，推荐https://github.com/MikeMcl/decimal.js/

ref：阮一峰：[浮点数的二进制表示](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)

# Number延展知识

## 向下取整

- 调用Math

```
Math.floor(num);
```

- 位运算

```
let num = 1.23
let num1 = num | 0;
console.log(num1)  // 1
```

- 取反操作符

```
~~num  //1
```

## 向上取整

```
math.ceil(num)
```

## 保留小数点有效位数

1.toFixed()：这个函数目前浏览器都支持得比较好，但它的小数部分是定长的，不会因为后面是0就自动舍弃掉，会出现1.00，3.50这样的数据

2.Math.round(x * 100) / 100;不会补0